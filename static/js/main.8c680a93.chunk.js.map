{"version":3,"sources":["MapComponent.jsx","DataModule.jsx","App.jsx","serviceWorker.js","index.jsx","data/daily.csv","data/table.csv"],"names":["bounds","GemOverview","feature","selectedGem","useState","permanent","setPermanent","useEffect","find","x","value","id","Tooltip","key","properties","statnaam","confirmed","MapComponent","appData","geo","mapRef","useRef","console","log","Map","maxBounds","className","data","type","features","valueProperty","scale","steps","mode","style","fillColor","weight","opacity","color","dashArray","fillOpacity","ref","TileLayer","url","parser","filePath","Papa","parse","header","DataModule","setAppData","startDate","setStartDate","setSelectedGem","dailySum","useSWR","daily","k","fetch","then","r","text","history","table","dailySumData","useMemo","historyData","gemList","gem","map","label","options","dailyFilter","all","startDateT","first","parseISO","last","slice","startDateToIso","formatISO","representation","d","date","total","a1","a2","min","max","default","selected","dailyDefault","transMuniCode","code","padStart","allFilter","itm","item","filterData","onChange","placeholderText","minDate","maxDate","placeholder","isMulti","classNamePrefix","a","clearValue","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message","module","exports"],"mappings":"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","file":"static/js/main.8c680a93.chunk.js","sourcesContent":["import React, { useState, useEffect, useRef } from 'react'\n\nimport { Map, Popup, Tooltip, Marker, TileLayer } from 'react-leaflet'\nimport Choropleth from 'react-leaflet-choropleth'\n\nconst coordinates = [52.187, 5.076]\nconst bounds = [\n  [50.803721015, 3.31497114423],\n  [53.5104033474, 7.09205325687],\n]\nconst GemOverview = ({ feature, selectedGem }) => {\n  const [permanent, setPermanent] = useState(null)\n  useEffect(() => {\n    if (selectedGem) {\n      if (selectedGem.find(x => x.value === feature.id)) {\n        setPermanent(true)\n      } else {\n        setPermanent('')\n      }\n    } else {\n      setPermanent('')\n    }\n  }, [selectedGem, feature])\n\n  return (\n    <Tooltip key={permanent} permanent={permanent}>\n      <h1>{feature.properties.statnaam}</h1>\n      <br></br>\n      <p>{feature.confirmed}</p>\n    </Tooltip>\n  )\n}\n\nconst MapComponent = ({ appData, selectedGem }) => {\n  const geo = appData.geo\n  const mapRef = useRef()\n  console.log(mapRef)\n  //   const style = {\n  //     fillColor: '#F28F3B',\n  //     weight: 2,\n  //     opacity: 1,\n  //     color: 'white',\n  //     dashArray: '3',\n  //     fillOpacity: 0.5\n  // }\n  const myMarkers = {\n    markers: [\n      { key: 'marker1', position: [51.5, -0.1], content: 'My first popup' },\n      { key: 'marker2', position: [51.51, -0.1], content: 'My second popup' },\n      { key: 'marker3', position: [51.49, -0.05], content: 'My third popup' },\n    ],\n  }\n  const onEachFeature = (feature, layer) => {\n    layer\n      .bindTooltip(feature.properties.statnaam)\n      .openTooltip(\n        `${feature.properties.statnaam} <br>Confirmed:${feature.confirmed}`\n      )\n  }\n  const style = {\n    fillColor: '#F28F3B',\n    weight: 2,\n    opacity: 1,\n    color: 'white',\n    dashArray: '3',\n    fillOpacity: 0.5,\n  }\n\n  return (\n    <Map bounds={bounds} maxBounds={bounds} className='map-container'>\n      <Choropleth\n        data={{ type: 'FeatureCollection', features: geo }}\n        valueProperty={feature => feature.confirmed}\n        scale={['green', 'red']}\n        steps={7}\n        mode='q'\n        style={style}\n        ref={mapRef}\n      >\n        <GemOverview selectedGem={selectedGem}></GemOverview>\n      </Choropleth>\n      <TileLayer url='http://{s}.tile.osm.org/{z}/{x}/{y}.png' />\n    </Map>\n  )\n}\n\nexport default MapComponent\n","import React, { useState, useEffect, useMemo } from 'react'\nimport gem from './data/gemeente_2020.json'\nimport daily from './data/daily.csv'\nimport table from './data/table.csv'\n\nimport MapComponent from './MapComponent'\nimport useSWR from 'swr'\n\nimport Select from 'react-select'\n\nimport DatePicker from 'react-datepicker'\nimport { parseISO, formatISO } from 'date-fns'\n\nimport Papa from 'papaparse'\n\nconst Overview = ({ selectedGem }) => {\n  return selectedGem.map(x => (\n    <>\n      <div className='gem-container-box'>\n        <h1>{x.properties.statnaam}</h1>\n        <p>Confirmed: {x.confirmed}</p>\n      </div>\n    </>\n  ))\n}\n\nconst filterData = (daily, all, startDate) => {\n  const date = 'Datum'\n  const total = 'Aantal'\n  const startDateISO = '2020-03-14'\n  const code = 'Gemeentecode'\n  const muni = 'Gemeentenaam'\n  const prov = 'Provincienaam'\n\n  const first = parseISO(daily[0][date])\n  const last = parseISO(daily.slice(-1)[0][date])\n\n  console.log(daily)\n  let startDateT\n  if (startDate) {\n    const startDateToIso = formatISO(startDate, { representation: 'date' })\n    startDateT = startDateToIso\n  }\n  if (!startDate) {\n    startDateT = formatISO(last, { representation: 'date' })\n  }\n\n  const dailyC = daily.map(d => {\n    return {\n      date: d[date],\n      total: d[total],\n    }\n  })\n  const dailyDefault = () => {\n    if (startDate) {\n      const selected = daily.find(d => d[date] === startDateT)\n      return parseISO(selected[date])\n    } else {\n      return last\n    }\n  }\n\n  const dailyFilter = { min: first, max: last, default: dailyDefault() }\n\n  const transMuniCode = code => 'GM' + code.padStart(4, '0')\n\n  const allFilter = all.map(d => {\n    return {\n      id: transMuniCode(d[code]),\n      confirmed: d[startDateT],\n    }\n  })\n  const mergeById = (a1, a2) =>\n    a1.map(itm => ({\n      ...a2.find(item => item.id === itm.id && item),\n      ...itm,\n    }))\n  const geo = mergeById(gem.features, allFilter)\n\n  return { dailyFilter, geo }\n}\n\nconst parser = filePath => {\n  const result = Papa.parse(filePath, {\n    header: true,\n  })\n\n  return result.data\n}\n\nconst DataModule = () => {\n  const [appData, setAppData] = useState(null)\n  const [startDate, setStartDate] = useState(null)\n  const [selectedGem, setSelectedGem] = useState([])\n\n  const { data: dailySum } = useSWR(daily, k =>\n    fetch(k, { mode: 'cors' }).then(r => r.text())\n  )\n  const { data: history } = useSWR(table, k =>\n    fetch(k, { mode: 'cors' }).then(r => r.text())\n  )\n\n  const dailySumData = useMemo(() => dailySum && parser(dailySum), [dailySum])\n  const historyData = useMemo(() => history && parser(history), [history])\n  const gemList = gem.features.map(x => ({\n    value: x.id,\n    label: x.properties.statnaam,\n  }))\n  const options = useMemo(() => appData && appData.dailyFilter, [appData])\n\n  useEffect(() => {\n    if (!dailySumData || !historyData) {\n      return\n    }\n    // dailySumData.data.slice(-1)[0]\n    setAppData(filterData(dailySumData, historyData, startDate))\n  }, [dailySumData, historyData, startDate])\n  console.log(selectedGem)\n  const handleKeyChange = a => {\n    // const copy = []\n    // if (a) {\n    //   a.forEach(x => {\n    //     const res = appData.geo.filter(z => z.id === x.value)\n    //     copy.push(...res)\n    //   })\n    // }\n    setSelectedGem(a)\n  }\n\n  if (!appData) {\n    return <div>Loading...</div>\n  }\n\n  return (\n    <>\n      <div className='grid'>\n        <MapComponent\n          appData={appData}\n          selectedGem={selectedGem}\n        ></MapComponent>\n\n        <div className='text-container'>\n          <DatePicker\n            selected={startDate}\n            onChange={date => setStartDate(date)}\n            placeholderText='This only includes today and tomorrow'\n            minDate={options.min}\n            maxDate={options.max}\n          />\n          <Select\n            placeholder='Municipality'\n            isMulti\n            options={gemList}\n            className='basic-multi-select'\n            classNamePrefix='select'\n            onChange={handleKeyChange}\n            clearValue={() => setSelectedGem([])}\n          />\n        </div>\n      </div>\n    </>\n  )\n}\n\nexport default DataModule\n","import React from 'react'\nimport 'leaflet/dist/leaflet.css'\nimport 'react-datepicker/dist/react-datepicker.css'\nimport './App.css'\n\nimport DataModule from './DataModule'\n\nfunction App() {\n  return (\n    <div className='App'>\n      <DataModule></DataModule>\n    </div>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n","module.exports = __webpack_public_path__ + \"static/media/daily.ed720987.csv\";","module.exports = __webpack_public_path__ + \"static/media/table.6365c10e.csv\";"],"sourceRoot":""}